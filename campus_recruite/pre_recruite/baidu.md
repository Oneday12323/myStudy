# baidu
## **1. 【计网】计算机网络七层模型**
> 【计网】计算机网络七层模型

- **物理层** - 定义了机械、电气、功能和规程等方面的特性,用于传输原始bit流。例如双绞线、同轴电缆、光纤等。
- **数据链路层** - 在网络中的两个相邻节点之间可靠地传输数据帧。实现流量控制、差错控制、访问控制、地址控制等功能。例如Ethernet协议属于这一层。
- **网络层** - 为数据包选择路由,使源主机和目标主机上的进程可交换分组。负责网络互连和路由选择,例如IP协议属于这一层。
- **传输层** - 提供进程间的通用数据传输服务。负责端到端的连接,进行流量控制、差错控制和确认重传等。例如TCP和UDP协议属于这一层。
- **会话层** - 建立、管理和终止会话。负责不同主机上的进程间的会话维护,Performing dialog control and synchronization.例如RPC属于这一层。
- **表示层** - 对数据进行翻译、加密和压缩等处理,保证传输的信息可读、完整。提供数据的语法分析、数据的格式变换、信息的加密等功能。
- **应用层** - 向用户提供网络服务。例如HTTP、DNS等都属于应用层协议。

## **2. 【计网】tcp和udp有什么区别，适用的场景**
> **TCP 和 UDP 是两种常用的传输层协议,主要有以下几点区别:**

- **连接性**:TCP 是面向连接的协议,在传输数据之前需要建立连接,数据传输结束后释放连接。UDP 是无连接的协议,source 和 destination 之间不建立连接就可以直接传输数据。
- **可靠性**:TCP 提供可靠的服务,通过flow control, congestion control, ACK,SEQ 等机制确保数据按顺序可靠地传到对方。UDP 不保证可靠传输,可能出现丢包、错序等情况。
- **传输速率**:TCP的传输速率相对较慢,因为要维持连接状态,还要进行流量控制和拥塞控制。UDP 的传输速率较快,没有连接建立和终止的开销。
> **使用场景**:

- TCP 用于对可靠性要求较高的情况,如文件传输、邮件传输等。
- UDP 用于对实时性要求较高而对可靠性要求不高的情况,如视频直播、网络电话等。
- TCP 用于需要确认和重传的应用,UDP 用于对时效性要求较高的应用。

**一句话,TCP保证数据完整性,UDP保证实时性。**

## **3. 【计网】tcp三次握手，四次挥手**

> TCP 的三次握手过程如下:

- 客户端向服务器端发送一个SYN数据包,标志位SYN=1,Seq=x
- 服务器收到SYN包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(seq=y),即SYN+ACK包,标志位SYN=1,ACK=1,Seq=y。
- 客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=y+1),标志位ACK=1,Seq=x+1。

至此,三次握手完成,客户端与服务器端建立连接。

> TCP 的四次挥手过程:

- 客户端发送一个FIN,用来关闭客户端到服务器的数据传送,标志位FIN=1,Seq=u
- 服务器收到FIN后,发送一个ACK确认包,标志位ACK=1,Seq=v,v=u+1
- 服务器发送一个FIN,用来关闭服务器到客户端的数据传送,标志位FIN=1,Seq=w
- 客户端收到FIN后,发送一个ACK确认包,标志位ACK=1,Seq=x,x=w+1

至此,四次挥手完成,客户端与服务器端关闭连接。

**三次握手建立可靠的TCP连接,四次挥手释放连接,可以避免连接被意外终止而出现半连接的情况。**

## **4. 【计网】https是怎么加密的，非对称加密解释一下**

> **HTTPS利用SSL/TLS提供安全的数据传输,其加密原理主要包括**:

- 对称加密:客户端和服务器端协商生成共享的会话密钥,然后使用该会话密钥和对称加密算法(如AES)对数据进行加密。
- 非对称加密:用于等待对称加密算法协商会话密钥。服务器端的 SSL 证书中包含服务器公钥,客户端利用服务器公钥加密会话密钥并发送给服务器,服务器使用自己的私钥解密获取会话密钥。
- 消息认证码:利用哈希算法生成摘要,用于验证消息的完整性和认证通信方身份。

> **非对称加密简单来说就是使用一对公钥和私钥,其特点是**:

- 公钥用于加密,私钥用于解密;
- 公钥可以公开,私钥需要保密;
- 用公钥加密的信息只能用对应的私钥解密;
- 私钥无法根据公钥推导出来。

***在HTTPS中,客户端拿到服务器的公钥来加密会话密钥,服务器用自己的私钥解密,实现安全地协商会话密钥。这保证了通信的安全性。***

## **5. 【算法】二分法的原理和时间复杂度**

**二分法的原理:**
> 是将待搜索的区间分成两部分,通过与中间值的比较来判断在哪一部分继续搜索,将搜索的区间减少一半,由此重复划分区间和比较,直到找到要搜索的目标。

*二分法的时间复杂度为 **O(logn)。***

**搜索过程如下:**

- 定义搜索区间的两个端点l和r。
- 计算区间的中间位置m = (l + r) / 2。
- 将m与目标值x进行比较:
如果m == x,返回m的位置。
如果m > x,则目标值在左区间[l, m - 1],设置r = m - 1。
如果m < x,则目标值在右区间[m + 1, r],设置l = m + 1。
- 重复步骤2和3,直到找到目标值。

*由于每次比较都使搜索区间缩小一半,如果元素数量为n,则经过logn次比较就可以找到目标值。所以时间复杂度为O(logn)。*

二分法利用了区间缩减的思想,是一种非常高效的搜索算法。需要注意,该算法要求搜索空间必须有序。

## **6. 【数据库】count统计总数的话里面有null的情况会统计进去吗？什么时候不会统计什么时候会统计？**

> 在使用 count 统计总数时,含有 null 值的情况统计进去还是不统计进去,主要取决于**count的实现方式**:

- 如果是**调用集合的 size() 方法**,由于 size 方法会统计集合的元素数量,包含 null 在内的所有元素都会被统计。
- 如果是**对流进行 count 操作**,比如 List.stream().count(),含有 null 值默认是会统计进去的。
- 如果**在 count 前过滤掉 null 值**,那么 null 值就不会被统计。
- - 例如 List.stream().filter(x -> x != null).count()。

- 在某些具体实现中,StatisticCounter 统计计数器会区分 null 值和非 null 值,可以单独获取两者的数量。

- 在 SQL 中,count(*) 会统计全部行数,包括 null 值。count(列名) 只统计该列非 null 值的行数。

所以,使用 count 统计时需要注意根据具体的实现方式,判断 null 值是否被统计进去了。如果不希望统计 null,需要提前过滤掉 null 值或在 count 时指定非 null 的列。


## **7. 【数据库】sum求和的时候null怎么处理**

> **在使用 sum 求和时,含有 null 值需要特殊处理,常见的做法有:**

- 在求和前,先过滤掉 null 值,然后对非空的值进行求和。

例如:
```sql
List<Integer> list = Arrays.asList(1, 2, null, 3);
Integer sum = list.stream().filter(x -> x != null).mapToInt(x -> x).sum();
```

- 使用函数替换 null 值,转换为一个默认的数字,然后进行求和。

例如:
```sql
List<Integer> list = Arrays.asList(1, 2, null, 3);
Integer sum = list.stream().map(x -> x == null ? 0 : x).mapToInt(x -> x).sum();
```

- 先统计非空值的个数,然后乘以平均值得到总和。

例如:
```sql
int count = list.stream().filter(x -> x != null).count();
double average = list.stream().filter(x -> x != null).mapToInt(x -> x).average().orElse(0);
double sum = count * average;
```

- 在数据库中,可使用 COALESCE 或 IFNULL 函数转换 null 值,例如:

```SELECT SUM(COALESCE(column, 0)) FROM table;```

- 在某些统计类库中,sum 方法可能自带 null 值处理,可以直接调用。

所以,在代码中进行null值校验,或者使用相关函数转换null值,是处理sum求和时null值的常用方法。

8. 【算法】常用的算法，说出思路并说出时间复杂度

> **这里介绍几种常用算法的思路和时间复杂度:**

- **二分查找:**
思路:将待搜索区间按照中间点分成两半,缩小搜索范围来加速查找。
时间复杂度:O(logn)
- **快速排序:**
思路:选择一个pivot,将小于pivot的元素放到左区间,大于pivot的放到右区间。递归进行划分。
时间复杂度:平均O(nlogn),最坏O(n^2)
- **线性查找:**
思路:从头到尾逐个查找目标元素。
时间复杂度:O(n)
- **内插查找:**
思路:根据目标值在数据集中的可能位置来确定搜索点。
时间复杂度:O(loglogn)
- **希尔排序:**
思路:按增量进行插入排序,重复操作直到增量为1。
时间复杂度:O(nlogn)
- **哈希查找:**
思路:使用哈希函数将键映射到表中一个位置。
时间复杂度:平均O(1)
- **广度优先搜索:**
思路:从源节点开始,先访问所有的邻节点,然后依次访问更外层邻节点。
时间复杂度:O(|V|+|E|)
- **深度优先搜索:**
思路:从源节点开始,递归访问每个分支的所有节点。
时间复杂度:O(|V|+|E|)

## **9. 【算法】快速排序的思路及时间复杂度**

## **10. 【nodejs】nodejs有什么特性？**
> **Node.js 有以下几个重要特性:**

- 异步和非阻塞 I/O
Node.js 使用事件驱动和非阻塞 I/O 模型,使其轻量又高效。没有线程开销,程序响应速度快。

-高并发
Node.js 的异步非阻塞模型可以处理大量并发请求,非常适合 I/O 密集型应用。

- 快速开发
Node.js 使用 JavaScript 语言,降低开发门槛,可以方便快速开发应用程序。大量成熟的第三方模块也使开发更简单。

- 灵活性
Node.js 可以用于开发各种类型的应用,如 Web 应用、API 服务、命令行工具、桌面应用等。

- 优秀的生态系统
Node.js 拥有庞大的生态系统,有大量优质的软件库和工具可用。组件复用性高,降低重复工作量。

- 单线程模式
Node.js 使用单线程运行事件循环,避免多线程的复杂同步问题。操作系统可同时处理多个请求。

综上,Node.js 以其异步非阻塞的高性能,以及快速开发的特点,非常适合构建 I/O 密集型网络应用。它拥有活跃的社区和丰富的组件,是 JavaScript 服务器端编程的首选。

## **11. 【nodejs】nodejs的事件循环？**

> Node.js 的事件循环和浏览器的事件循环原理上都是基于事件驱动的设计,都采用单线程处理事件的循环方式。但是两者的实现还是有一些区别的:

- Node.js 的事件循环只有一个,处理所有的事件。浏览器的事件循环一个Tab页可能会有多个,如主线程事件循环,Web Worker事件循环等。
- Node.js 使用的 libuv 库来处理事件循环,浏览器使用自身的事件循环实现。libuv 更加高效,而浏览器的事件循环需要与渲染等功能协调。
- Node.js 的事件循环分阶段执行,包括定时器、待定回调、CLOSE 回调、POLL 等阶段。浏览器的事件循环分任务队列,如 macrotask 队列和 microtask 队列。
- Node.js 可以手动处理事件循环,如process.nextTick()。浏览器的事件循环完全由浏览器自身控制。
- Node.js 的事件循环不会阻塞,完全是异步非阻塞的。浏览器由于 DOM 渲染可能会造成阻塞。
- Node.js 通过事件循环可实现高并发处理。浏览器同时只能处理一个事件。

综上,Node.js 的事件循环更加高效、灵活且不会阻塞,而浏览器的事件循环需要协调更多功能,相对来说复杂度更高。这也使得 Node.js 更适合 I/O 密集型应用。
## **12. 【BOM】浏览器的事件循环？**

> 浏览器的事件循环机制详解如下:

- 浏览器的事件循环是单线程的,也就是同一时间只能执行一个任务。

**任务分为同步任务和异步任务两类。**

- 同步任务指的是必须立即执行的任务,会在调用栈中按顺序立即执行。
- 异步任务指那些不需要立即返回结果的任务,它们会在需要时移入任务队列,等待后续执行。

- 异步任务分为微任务(microtask)和宏任务(macrotask)。
微任务包括Promise回调、MutaionObserver等,它们的优先级最高,在当前调用栈清空后立即执行。

- 宏任务包括setTimeout、setInterval、DOM事件回调等,只有在同步任务和所有微任务执行完毕后,才会被移入执行。

- 事件循环的顺序是:执行同步代码 --> 执行当前微任务 --> 执行宏任务中的一个任务 --> 渲染更新 --> 下一个事件循环周期

**不同的Tab页面有其自己的事件循环,它们互不影响。**

如果某个同步任务执行时间过长,会造成页面渲染更新的阻塞。
综上,浏览器的事件循环机制可以协调同步任务与异步任务的执行,确保主线程不会被阻塞,UI渲染及时更新。

## **13. 【css】实现上面固定，左侧固定，右侧自适应的布局**
- 尝试使用css计算属性


## **14.【BOM】浏览器渲染页面的过程**

**浏览器渲染页面的主要过程包括:**

- 解析HTML构建DOM树。浏览器会解析HTML代码,构建DOM树,表示页面的节点树形结构。
- 解析CSS构建CSSOM树。浏览器会解析样式信息,构建CSSOM树,表示样式规则。
- 构建Render树。将DOM树和CSSOM树整合形成一棵Render树,以用于页面布局和渲染。
- 布局Layout。计算Render树每个节点在视窗中的确切坐标。
绘制Painting。遍历Render树,绘制每个节点的内容。
- 合成Compositing。将渲染的各个层进行叠加形成最终图像。

*所以浏览器页面渲染的基本流程是:*

***HTML解析构建DOM → CSS解析构建CSSOM → 构建Render树 → 布局计算 → 绘制绘制 → 图层合成***

> **此过程是递归逐层进行的, Layout和Painting会根据视窗变化多次重复执行。**

渲染过程是在主线程上同步执行的,如果某个环节耗时过长,会阻塞页面的渲染更新,导致页面卡顿。

## **15. defer和async**
> **script标签中 defer 和 async 的区别**
1. 执行时机不同: - defer:延迟到文档被解析完成后,DOMContentLoaded事件前执行 - async:下载完成后立即执行,不会延迟文档解析 
2. 执行顺序不同: - defer:按照在页面中出现的顺序依次执行 - async:无序执行 
3. 文档解析区别: - defer:文档会在该脚本加载完后再继续解析 - async:文档不会等待该脚本加载完就继续解析 
4. quantity: defer:只对外联脚本有效 - async:对内联脚本也有效 所以,如果需要维持脚本的执行顺序,可以使用 defer。如果需要异步执行且对顺序没有要求,可以使用 async。内联脚本需要异步执行可以使用 async。 
**一句话总结两者区别: defer 是“温和的”异步,async 是“激进的”异步。**







消息队列(Message Queue)是一种进程间通信的机制,主要具有以下特点:

消息的发送与接收是异步的(decoupled)。发送进程只管发送,不需要立刻获得响应。
消息队列提供了一个临时的存储空间,保存消息直到接收进程取走消息。
接收进程则从队列中取出消息进行处理。消息一旦被取走,就从队列中删除。
消息队列具有排队能力,可以确保消息的顺序。
消息队列还可以起到缓冲的作用,可以平滑发送速率和接收速率的差异。
使用消息队列的好处是可以提高系统的灵活性、可伸缩性、健壮性、安全性。发送进程和接收进程可以独立扩展且独立部署。

常见的消息队列实现包括:RabbitMQ、Kafka、Redis 等。使用消息队列可以实现异步处理、削峰填谷、广播消费、顺序保证等功能。

总体来说,消息队列是实现进程间异步通信的有用机制,具有确保消息顺序、平滑波动和存储消息等优点。可以用来构建高扩展性、高可用性的分布式系统。

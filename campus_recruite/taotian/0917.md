项目上的事问的挺多的
1.说一下commonJs和ES6
2.vue的生命周期，为什么有这个设计
3.讲一讲小程序和web端开发的区别
4.深拷贝和浅拷贝，js为什么会出现这个问题
5.说一下webpack
6.说一下array的sort方法
7.讲一下快排原理和时间复杂度
8.了解过哪些前端框架，谈一谈
9.了解微内核宏内核吗
10.介绍一下SVM原理(支持向量机)
11.settimeout运行时间和实际时间有些出入，为什么
12.说一下diff算法
13.了解eventloop吗




2. vue3和vue2的区别
3. 了解什么最新的技术么（说了vite， SWC，esbuild， jetpack， webgpu）
4. 如何自学前端的
5. 写道算法题
    求最长符合规范的字串
    字符串中只包含 '(' 和 ')' ，规范就是括号的开闭匹配
    用的动态规划写出来了

    给你一个URL能够发现什么信息，对URL进行了很细致深入的询问，记不得了
2、bom相关的，记不得了，然后问到了hash
3、对hash进行深入的问，之后问和history区别
4、css画三角形以及原理，空心三角形怎么画
5、es6和es5区别，数据类型，null和undefined双等，三等之类的，Boolean原理
之后出题，然后判断
写一个#和rgb转换函数

1. 介绍一下项目（我项目比较简单，就聊了10min）
2. html中的head你会写什么内容
3. 怎么做移动端适配
4. 对盒子模型的理解
5. flex布局如何元素做到自动换行
6. 你平时怎么做动画的
7. 你刚刚提到的translate性能好主要体现在哪方面（主要讲了下硬件加速的原理）
8. js的异步是怎么实现的
9. vue和react更熟悉哪一个（完全不会react，最后反问问技术栈，闲鱼部门都是用的react， g）
10. vue的双向数据绑定怎么实现的
11. vue3相比与vue2的优化（主要讲了双向绑定和diff算法的优化）
12. 虚拟dom树的作用
13. 如何用udp协议实现tcp协议的可靠传输（不会， g）
14. 如果让你给我推荐几本前端技术相关的书籍， 你会推荐哪几本（我b站上的大学， 哪看过书啊， g）
15. 螺旋遍历矩阵



## 从渲染的角度讲一下transition和transform的区别

transition是CSS3中新增的一个属性,它可以在不使用Flash或JavaScript的情况下,当元素从一种样式变换为另一种样式时为元素添加效果。transition本质上是定义元素样式改变时的过渡效果,比如元素的颜色、大小、位置等发生变化时,这种变化不是瞬间完成的,而是经过一个过程。

transform也是CSS3中新增的属性,它允许对元素进行旋转、缩放、倾斜、平移等转换,从而改变元素的形状和位置。transform的变换是瞬时完成的,不需要过渡过程。

从渲染的角度看,transition实现样式变化的过渡效果需要渲染多次帧以实现动画效果,因此对性能消耗比较大。而transform变换是瞬时完成的,只需要重新渲染一次来呈现变换后的效果,性能消耗相对较小。

所以,如果只是需要元素做个简单的位移或缩放,优先考虑使用transform,能节省渲染资源。如果需要实现复杂的补间动画,则需要使用transition,这时就需要权衡渲染性能的损耗和动画效果的流畅性了。

总之,从渲染角度来看,transform和transition各有优势,开发者需要根据实际场景需求,选择合适的属性来实现元素的样式变换。


## 重排和重绘
好的,我来解释下重排(reflow)和重绘(repaint)的区别:

- 重排(reflow): 当页面的DOM元素的尺寸、结构、或某些属性发生变化时,浏览器必须重新计算元素的几何属性,这个过程就称为重排。重排时,浏览器会重新计算元素的几何属性,如宽高、位置等,并且所有受影响的元素也会重新渲染。重排的代价是昂贵的,可能会影响性能。

- 重绘(repaint): 当页面的样式发生变化时,浏览器会把影响到的部分重新绘制,这个过程称为重绘。比如改变元素的背景色、文字颜色等,不影响布局的样式就只会引发重绘。重绘的代价相对较小,只是影响了元素的外观显示。

总结一下:

- 重排必将导致重绘,因为几何属性改变了必须重新渲染。但重绘不一定会导致重排。
- 重排的代价高于重绘,应该尽量避免频繁的重排。
- 提高性能的方法:将多次重排的操作合并成一次;避免设置会触发重排的样式;使用动画实现复杂的动效等。

所以在网页开发时,我们应该尽量避免触发大区域的重排,只进行局部的重绘,以此来优化网页性能。


## 低代码渲染引擎
低代码平台的渲染引擎实现主要有以下几种方式:

1. 基于浏览器内核

直接利用浏览器自带的渲染引擎,通过封装浏览器内核来实现页面和组件的渲染。优点是开发便捷,兼容性好,缺点是性能较差。

2. 自定义渲染引擎

不依赖浏览器内核,自研一套渲染引擎。基于 Canvas 或者 WebGL 等技术实现布局、绘制和组件化。优化渲染效率但兼容性较差。

3. 基于 React/Vue

使用 React、Vue 等现成的前端框架作为视图层解决方案。可以借助其虚拟 DOM 和组件化方案来实现。优点是开发效率高、生态完善。

4. 基于原生小程序

部分低代码平台是建立在微信/支付宝/字节小程序技术之上的,可以直接用它们的渲染引擎。优点是性能好,缺点是多端适配性差。

5. 混合模式

根据产品形态和使用场景,选择不同的技术方案进行混合实现。例如编辑器使用浏览器内核,而运行环境使用高性能定制渲染引擎。

总之,低代码渲染引擎的实现要考虑性能、兼容性、开发效率等因素,需要根据具体场景进行技术选型和定制。
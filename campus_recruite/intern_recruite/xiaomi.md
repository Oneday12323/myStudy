# xiaomi一面
## **1. 【vueRouter】动态路由是怎么实现的？**

## **2. 【表单】表单定位错误怎么实现**

## **3. 【算法】最大子序和**

## **4. 【数组】数组扁平化并且去重**

## **5. 事件循环**

## **6. 【计网】http缓存**

> HTTP中的缓存策略主要分为强制缓存和协商缓存:

1. 强制缓存

不需要再次请求服务器,直接从浏览器缓存中读取结果。包括:

- 浏览器缓存:根据响应头的Cache-control等规则进行缓存。

- 预检请求:发送一个条件请求,如果资源未修改返回304直接使用缓存。

2. 协商缓存 

需要重新向服务器验证缓存的有效性。根据服务器响应决定是否使用缓存。包括:

- Last-Modified / If-Modified-Since

- ETag / If-None-Match

协商缓存需要请求服务器判断缓存是否仍然有效,不如强制缓存简单直接。

但可以确保返回给客户端的是服务器的最新资源,保证缓存与服务器同步。

所以实际应用中两者往往结合使用,先协商缓存验证,再查找强制缓存结果,以提高缓存命中率。
HTTP缓存相关的响应头字段中,优先级从高到低顺序如下:

1. Cache-Control

Cache-Control 中的 max-age、s-maxage、public、private 等指令会直接决定缓存策略,优先级最高。

2. Expires

Expires  header 提供了绝对过期时间,如果过期就不能使用缓存而需要重新请求。

3. Last-Modified 和 ETag

Last-Modified表示资源的最后修改时间,ETag是资源的特征标识符,用于协商缓存是否仍然有效。

它们与 If-Modified-Since、If-None-Match 对比判断缓存是否失效。

4. Age

Age 记录当前缓存已经存活的时间,可以决定缓存是否过期需要重新验证。

5. Date

Date 为响应生成的时间,和 Age 配合计算缓存过期时间。

6. Pragma

Pragma 字段也可以设置缓存指令,但是已经被 Cache-Control 取代,不再推荐使用。

综合利用上述各个字段就可以实现 web 应用的缓存优化,提高性能和用户体验。Cache-Control 的优先级最高,约定优于配置。

## **7. 【场景】实现一个登录，前后端要怎么交互？**

## **8. 【BOM】localstorage**

## **9. 【计网】进程和线程有什么区别？**

## **10. 【javaScript】js判断数据类型，为什么typeof null返回的是object？**

11. 



# xiaomi二面
## **1. 【vue】遍历列表的时候为什么要加key？**

## **2. 【】从输入一个url到页面展现，经过了什么过程**